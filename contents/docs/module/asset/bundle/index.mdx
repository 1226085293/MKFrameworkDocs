---
title: Bundle
description: Bundle 管理：加载 / 预加载 / 场景切换 / 热更 与 管理器基类
order: 1
---

本文以工程实战角度说明框架内的 **Bundle 管理器 `mk.bundle`（`MKBundle`）** 的使用方法、重要约定与实现要点。内容覆盖：模块概览、主要 API、Bundle 生命周期、Bundle 管理器基类(`BundleManageBase`)、使用示例、常见陷阱与 PlantUML 图示，便于快速上手并避免误用。

---

## 模块概览

`mk.bundle` 封装 bundle 的加载 / 场景加载 / 预加载 / 热更，并提供 bundle/scene 切换事件和「bundle 管理器」机制用于子游戏或模块化管理。

核心能力：

-   加载（load）与预加载（preloadScene）场景；

-   支持远程/本地 bundle、bundle 热更（reload）；
-   切换前 / 切换后事件（bundle/scene）；
-   提供 `BundleManageBase` 作为 bundle 级管理器基类，方便注册生命周期、管理对象池、网络与资源释放；
-   提供 `followRelease` 机制，方便将资源/对象绑定到 bundle 生命周期。

---

## 重要概念与属性

-   `bundleMap: Map<string, BundleData>`：已知的 bundle 信息表（`BundleInfo` + 可选 `manage`）。

-   `bundleStr`：当前运行场景所属 bundle（getter/setter 会触发 bundle 切换流程）。
-   `sceneStr`：当前场景名（setter 会触发场景切换事件）。
-   `isSwitchScene`：当前是否处于场景切换流程中（loadScene 期间为 true）。
-   事件：`beforeBundleSwitch` / `afterBundleSwitch` / `beforeSceneSwitch` / `afterSceneSwitch`（通过 `mk.bundle.event` 订阅）。

---

## 主要 API

### set

`set(bundleInfo)`

注册或更新 bundle 信息（不会自动加载 bundle），示例：

```ts
mk.bundle.set({
    bundleStr: 'subgame1',
    originStr: 'https://cdn.example.com/subgame1', // 可选远程路径
    versionStr: 'bundle 的 md5 版本', // 可选版本号
});
```

`bundleMap` 会把该信息保存为 `BundleData`，后续 `load`/`loadScene` 会使用它。

---

### load

`load(bundleName | LoadConfig): Promise<AssetManager.Bundle | null>`

加载 bundle（若已存在则直接返回）。常见用法：

```ts
// 简单加载
await mk.bundle.load('subgame1');

// 带进度回调
await mk.bundle.load({
    bundleStr: 'subgame1',
    progressCallbackFunc: (c, t) => {
        /** 进度回调 */
    },
});
```

行为要点：

-   等待引擎初始化完成（`game` 的 `EVENT_GAME_INITED`）。

-   若 bundle 已在 `assetManager` 中，则直接返回并触发一次 `progressCallbackFunc(1,1)`（用于兼容 UI 进度）。
-   若需下载，会走 `assetManager.loadBundle(originStr, {version, onFileProgress}, cb)`。对于非远程 bundle，会在加载成功后模拟一次完成回调（`progressCallbackFunc(1,1)`）。

---

### loadScene

`loadScene(sceneName, SwitchSceneConfig): Promise<boolean>`

切换场景（支持预加载）。用法示例：

```ts
await mk.bundle.loadScene('MainScene', {
    bundleStr: 'main', // 要切到哪个 bundle 的场景
    progressCallbackFunc: (f, t) => {}, // 预加载进度（可选）
    beforeLoadCallbackFunc: directorOnBeforeLoad, // 场景加载前回调
});
```

关键流程与行为：

1. 等待 MKBundle 初始化任务完成；
2. 根据 `config.bundleStr` 找到或创建对应 `BundleInfo` 并调用 `load()`；
3. 如果 `config.progressCallbackFunc` 存在，则先 `preloadScene`（支持进度回调）；
4. 如果不是预加载并且 preload 成功：

    - 标记 `isSwitchScene = true`；

    - 若即将切换的 bundle 与当前 `bundleStr` 不同，会 `event.request(beforeBundleSwitch)`（可被拦截/等待）；
    - 发 `beforeSceneSwitch` 事件并等待所有监听完成；
    - 调用 `bundle.loadScene(sceneName, cb)`，完成后 `director.runScene(sceneAsset, beforeLoadCallback, onLaunched)`；
    - 成功后更新 `bundleStr`/`preSceneStr`/`sceneStr` 并触发 `afterBundleSwitch` / `afterSceneSwitch`；
    - 无论成功与否，最终把 `isSwitchScene` 置回 `false`。

注意：如果 `config.isPreload === true`，只做预加载并返回是否成功，不走切场景逻辑。

---

### reload

`reload(ReloadBundleInfo): Promise<AssetManager.Bundle | null>`（热更）

用于热更/重载某个 bundle（替换脚本、资源）。**限制**：在 PREVIEW 模式下不支持重载；不能在正在运行该 bundle 的场景内重载（必须在其他 bundle 场景下）。

`reload` 的主要步骤（实现细节）：

-   验证 `versionStr` 与非在当前 bundle 场景中；

-   收集并清理系统脚本缓存（System / scriptCache），删除该 bundle 的脚本模块；
-   注销、清理 ccclass（通过 `js.unregisterClass`）；
-   清理并 `releaseAll`（非 main bundle）并从 `assetManager` 移除原 bundle；
-   更新 `assetManager.downloader.bundleVers` 的版本号映射；
-   最后调用 `load(bundleInfo)` 重新加载新 bundle。

> 警告：reload 过程会**卸载旧脚本/资源**，若存在跨 bundle 单例或未清理的全局引用，会导致错误。热更前请确保所有 bundle 管理器/模块已正确清理。

---

## `BundleManageBase`（管理器基类）

`BundleManageBase` 提供 bundle 级管理能力：对象池、事件、网络、数据获取器以及 `followRelease`/`cancelRelease` 的实现。常用于把 bundle 内的通用资源、网络接口、共享数据放在一个地方，示例场景：子游戏管理器、功能侧模块集合管理。

关键点：

-   `abstract nameStr: string`：子类必须提供 bundle 名。构造时会自动把实例注册到 `mk.bundle.bundleMap`。

-   构造阶段会在下帧把自己加入 `mk.bundle`，并在非 EDITOR 环境运行父类生命周期 `init`/`open`/`close`（`mkToolFunc.runParentFunc`）。
-   `nodePoolTab`：按需创建 `NodePool`，方便复用节点。
-   `followRelease(object)` / `cancelRelease(object)`：通过内部 `_releaseManage` 管理对象释放，当管理器 `close()` 时会 `releaseAll()`。
-   生命周期约定：在编辑器模式仅 main bundle 的生命周期会自动跑（子 bundle 管理器在编辑器不会自动 open），`init()` 在从其他 bundle 切换到该 bundle 场景前调用，`open()` 在切换到该 bundle 场景时调用，`close()` 在从该 bundle 切出时调用。`close()` 会清理事件、网络事件、data、对象池，并释放所有跟随对象。

示例：

```ts
class MyBundleManage extends mkBundle.BundleManageBase {
    nameStr = 'subgame1';
    async init() {
        /* init resources */
    }
    async open() {
        /* start services */
    }
    close() {
        /* cleanup */
    }
}
```

---

## 常见使用示例（代码片段）

**注册 bundle 信息并加载：**

```ts
mk.bundle.set({ bundleStr: 'subgame1', originStr: 'https://cdn/x/subgame1' });
await mk.bundle.load('subgame1');
```

**切换场景（含预加载）：**

```ts
const ok = await mk.bundle.loadScene('Level01', {
    bundleStr: 'subgame1',
    progressCallbackFunc: (f, t) => console.log(f, t),
    beforeLoadCallbackFunc: directorOnBeforeLoad,
    launchedCallbackFunc: (err, scene) => console.log('launched', err),
});
if (!ok) {
    console.error('场景切换失败');
}
```

**热更 bundle（谨慎）：**

```ts
await mk.bundle.reload({
    bundleStr: 'subgame1',
    versionStr: '2025-08-01-01',
    originStr: 'https://cdn/x/subgame1',
    ccclassRegexp: /subgame1(_|\/)/,
});
```

**在 bundle 管理器里注册可被自动释放的对象：**

```ts
class MyManage extends mk.bundle.BundleManageBase {
  nameStr = 'subgame1';
  open() {
    const obj = mk.asset.get(...);
    this.followRelease(obj); // 会在 close 时被 releaseAll
  }
}
```

---

## 常见问题（FAQ）

**Q：为什么在编辑器里看不到子 bundle 管理器的 `open`？**
A：编辑器模式仅自动运行 main bundle 的生命周期，子 bundle 的管理器在编辑器下不会自动 `open`（除非手动运行）。

**Q：什么时候触发 `beforeBundleSwitch` / `afterBundleSwitch`？**
A：仅在真实切换 bundle（`bundle.name !== this._bundleStr`）时触发；在 `loadScene` 的切换流程中，先发 `beforeBundleSwitch`，成功切换后会发 `afterBundleSwitch`。监听者可通过 `event.request` 阻塞或异步等待。

**Q：reload 会卸载哪些东西？**
A：reload 会尝试清理脚本缓存（System / scriptCache）、注销 ccclass、释放 bundle 资源并从 `assetManager` 中移除旧 bundle。务必保证没有遗留的全局引用或未释放资源，否则可能抛异常或行为异常。`reload` 不在 PREVIEW 模式下支持。

**Q：main bundle 能被 `close()` 吗？**
A：`BundleManageBase.close()` 内禁止关闭 `main`（会抛异常 `"中断"`）。不要尝试关闭 main bundle。

---

## 风险与最佳实践

-   在调用 `reload` 前：确保当前运行场景不是被 reload 的 bundle（不能在该 bundle 的场景内重载）。
-   使用 `BundleManageBase` 管理资源和网络，所有通过 `followRelease` 注册的对象会在 `close()` 时自动释放，降低内存泄漏风险。
-   对于复杂热更场景，先在测试环境多次验证脚本卸载与资源释放顺序，避免遗留无效 ccclass 导致 `js.unregisterClass` 出错。
-   `loadScene` 的事件机制是可等待的（`event.request`），良好使用可避免场景切换中途被破坏的状态（比如弹窗未关闭、数据未 flush）。

---

## 图示（帮助理解）

### Bundle 管理器生命周期（PlantUML）
