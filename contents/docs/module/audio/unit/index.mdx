---
title: 音频单元
order: 1
---

## 介绍

音频单元是单个音频的信息集合和控制单元

## 创建

### 编辑器

```ts
@ccclass('ResourcesAudio')
export class ResourcesAudio extends mk.ViewBase {
    @property({ displayName: '音效', type: mk.Audio_.Unit })
    effect = new mk.Audio_.Unit();
}
```

### 动态加载

调用 [mk.audio.add](./manage#方法/add) 方法即可

## 属性

### groupIdNumList

当前所在分组 ID 列表，只读

### state

播放状态，只读

### waitPlayNum

等待播放次数，只读

### totalTimeSNum

总时长（秒），只读

### type

音频类型，只读

### realVolumeNum

真实音量，只读

### audioSource

音频组件，微信环境下为 null，只读

### event

音频事件对象，可用于监听音频状态变化

### clip

音频资源，AudioClip 类型

### volumeNum

音量

### isLoop

是否循环

### currentTimeSNum

当前时间（秒）

### isWaitPlay

等待播放开关

---

## 方法

### clone

克隆自身，返回一个新的音频单元对象，用于控制重叠播放

---

## 概念

### 等待播放

如果当前音频在播放状态时，再次调用 `mk.audio.play` 播放当前音频，会出现以下两种情况:

-   `isWaitPlay` 为 false 时: 当前音频重头开始播放
-   `isWaitPlay` 为 true 时: 当前音频不会重新开始播放，而是会累计 `waitPlayNum` 次数，等音频播放完成时再次播放 `waitPlayNum` 次数

### 音量

音频单元的音量受到音频组的影响，所以除了自身的音量`(volumeNum)`，还有一个根据自身的音频组`(groupIdNumList)`计算得到的真实音量`(realVolumeNum)`

真实音量的计算方式为：`自身音量 * 音频组1音量 * 音频组2音量 * 音频组n音量...`

### 重叠播放

通过 `clone` 得到多个相同资源的音频单元，然后获取停止状态的音频单元调用播放，即可做到重叠播放，
音频单元数量即最大重叠播放次数

示例：

```ts
class Test extends mk.ViewBase {
    @property({ displayName: '重叠音效', type: mk.Audio_.Unit })
    overlapEffect = new mk.Audio_.Unit();

    /** 重叠音频数组 */
    private _overlapEffectList!: mk.Audio_.Unit[];

    // 通过 clone 得到多个音频单元
    protected open(): void | Promise<void> {
        this._overlapEffectList.push(
            this.overlapEffect,
            this.overlapEffect.clone(),
            this.overlapEffect.clone()
        );
        // 或者如下
        // this._overlapEffectList.push(this.overlapEffect, ...Array.from({ length: 2 }, (v, k) => this.overlapEffect.clone()));
    }

    // 获取停止状态的音频单元播放
    clickAudio(): void {
        mk.audio.play(this._overlapEffectList.find((v) => v.state === mk.Audio_.State.Stop)!);
    }
}
```
